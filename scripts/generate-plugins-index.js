// scripts/generate-plugins-index.js
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, "..");

import pluginsConfig from "../plugins.config.js";

function fixImportPaths(filePath) {
    const content = fs.readFileSync(filePath, 'utf8');

    // Simply remove 'src/' from the path since we're now inside src/plugins/
    const updatedContent = content.replace(
        /from ['"]\.\.\/\.\.\/\.\.\/src\/([^'"]+)['"]/g,
        "from '../../../$1'"
    );

    fs.writeFileSync(filePath, updatedContent);
}

function copyAndFixPlugins(srcDir, destDir) {
    if (!fs.existsSync(destDir)) {
        fs.mkdirSync(destDir, { recursive: true });
    }

    const items = fs.readdirSync(srcDir);

    for (const item of items) {
        const srcPath = path.join(srcDir, item);
        const destPath = path.join(destDir, item);

        if (fs.statSync(srcPath).isDirectory()) {
            copyAndFixPlugins(srcPath, destPath);
        } else {
            fs.copyFileSync(srcPath, destPath);

            // Fix import paths in TypeScript files
            if (item.endsWith('.ts') || item.endsWith('.tsx')) {
                fixImportPaths(destPath);
            }
        }
    }
}

function generatePluginsIndex() {
    const imports = [];
    const exports = [];
    const pluginsByType = {};
    const allPluginTypes = ["collaborative_viewers", "viewers", "renderers", "loggers", "lsp", "backup", "themes"];

    const srcPluginsDir = path.join(rootDir, "src", "plugins");
    const rootExtrasDir = path.join(rootDir, "extras");

    // Create src/plugins directory if it doesn't exist
    fs.mkdirSync(srcPluginsDir, { recursive: true });

    // Copy all extras content to src/plugins and fix import paths
    console.log("Copying extras to src/plugins and fixing import paths...");
    copyAndFixPlugins(rootExtrasDir, srcPluginsDir);

    // For each plugin path in the config
    for (const pluginPath of pluginsConfig.plugins) {
        const pathParts = pluginPath.split("/");
        const pluginName = pathParts[pathParts.length - 1];
        const pluginType = pathParts[0];
        const pluginVarName = `${pluginName}${pluginType.charAt(0).toUpperCase() + pluginType.slice(1)}Plugin`;

        // Now reference the copied files in src/plugins
        imports.push(`import ${pluginVarName} from './${pluginPath}/index';`);
        exports.push(pluginVarName);

        if (!pluginsByType[pluginType]) {
            pluginsByType[pluginType] = [];
        }
        pluginsByType[pluginType].push(pluginVarName);
    }

    // Generate file content
    let content = `// This file is automatically generated. Do not edit directly.
// Generated on: ${new Date().toISOString()}

// Import all configured plugins
${imports.join("\n")}

// Export individual plugins
export {
${exports.map((name) => `  ${name}`).join(",\n")}
};

`;

    // Add type-based exports
    allPluginTypes.forEach(type => {
        const plugins = pluginsByType[type] || [];
        content += `// Export ${type} plugins as a group
export const ${type} = {
${plugins.map((name) => `  ${name}`).join(",\n")}
};

`;
    });

    // Add default export with structured plugins object
    content += `// Export the structured plugins object as default
export default {
${allPluginTypes.map(type => `  ${type}`).join(",\n")}
};
`;

    // Write the index file to src/plugins
    const outputPath = path.join(srcPluginsDir, "index.ts");
    fs.writeFileSync(outputPath, content);

    console.log(`Generated plugins index at ${outputPath}`);
}

// Run the generator
generatePluginsIndex();